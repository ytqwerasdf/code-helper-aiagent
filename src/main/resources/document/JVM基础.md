# JVM基础

## 初识JVM

###  什么是JVM

 JVM 全称是`Java Virtual Machine`，中文译名 Java虚拟机。本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。

###  JVM 的功能

- **解释和运行:**  对字节码文件中的指令， 实时的解释成机器码， 让计算机执行，实现跨平台特性
- **内存管理**
  - 自动为对象、方法等分配内存
  - 自动的垃圾回收机制， 回收不再使用的对象

- **即时编译** ：对热点代码进行优化， 提升执行效率

### 常见的JVM

| 名称                        | 作者    | 支持版本                   | 社区活跃度 （github star） | 特性                                                         | 适用场景                              |
| --------------------------- | ------- | -------------------------- | -------------------------- | ------------------------------------------------------------ | ------------------------------------- |
| HotSpot  (Oracle JDK版)     | Oracle  | 所有版本                   | 高(闭源)                   | 使用最广泛，稳定可靠，社区活跃 JIT支持 Oracle JDK默认虚拟机  | 默认                                  |
| HotSpot  (Open JDK版)       | Oracle  | 所有版本                   | 中(16.1k)                  | 同上 开源，Open JDK默认虚拟机                                | 默认 对JDK有二次开发需求              |
| GraalVM                     | Oracle  | 11, 17,19  企业版支持8     | 高（18.7k）                | 多语言支持 高性能、JIT、AOT支持                              | 微服务、云原生架构 需要多语言混合编程 |
| Dragonwell JDK 龙井         | Alibaba | 标准版8,11,17  扩展版11,17 | 低(3.9k)                   | 基于OpenJDK的增强 高性能、bug修复、安全性提升 JWarmup、ElasticHeap、Wisp特性支持 | 电商、物流、金融领域 对性能要求比较高 |
| Eclipse OpenJ9  (原 IBM J9) | IBM     | 8,11,17,19,20              | 低(3.1k)                   | 高性能、可扩展 JIT、AOT特性支持                              | 微服务、云原生架构                    |

**Java虚拟机规范**

- 《Java虚拟机规范》由Oracle制定，内容主要包含了Java虚拟机在设计和实现时需要遵守的规范，主 要包含class字节码文件的定义、类和接口的加载和初始化、指令集等内容。
- 《Java虚拟机规范》是对虚拟机设计的要求，而不是对Java设计的要求，也就是说虚拟机可以运行在 其他的语言比如Groovy、Scala生成的class字节码文件之上。
- 官网地址：https://docs.oracle.com/javase/specs/index.html

## 字节码文件详解

###  Java虚拟机的组成

![image-20250730151304663](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250730151304663.png)

- **类加载器**：加载class字节码文件 中的内容到内存中
- **解释器**：将字节码文件中的指令解 释成机器码
- **即时编译器**：编译热点代码，将编译后的机器码存入内存中方便直接调用
- **垃圾回收器**：回收不再被使用的对象

### 字节码文件的组成

使用`jclasslib`工具打开字节码文件

- **基础信息**
  - 魔数
  - 字节码文件对应的Java版本号 
  - 访问标识(public final等等) 
  - 父类和接口
- **常量池**：保存了字符串常量、类或接口名、字段名 主要在字节码指令中使用
- **字段**：当前类或接口声明的字段信息
- **方法**
  - 当前类或接口声明的方法信息 
  - 字节码指令
- **属性**：类的属性，比如源码的文件名 内部类的列表等

#### 字节码文件的组成 –基础信息

![image-20250730145929356](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250730145929356.png)

#### 字节码文件的组成部分-Magic魔数

- 文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改，不影响文件的内容。
- 软件使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。
-  Java字节码文件中，将文件头称为magic魔数。（CAFE BABE）

#### 字节码文件的组成部分-主副版本号

-  主副版本号指的是编译字节码文件的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1使用了 45.0-45.3，JDK1.2是46之后每升级一个大版本就加1；副版本号是当主版本号相同时作为区分不同 版本的标识，一般只需要关心主版本号。
-  版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容。

#### 字节码文件的组成部分-常量池

- 字节码文件中常量池的作用：避免相同的内容重复定义，节省空间。
- 常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。
- 字节码指令中通过编号引用到常量池的过程称之为符号引用。

#### 字节码文件的组成部分-方法

-  字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的Code属性中。
- 操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置。

**示例**：int i = 0; i = i++; 最终i的值是多少？

```
-----字节码指令
iconst_0		将0放入操作数栈
istore_1		从操作数栈取出放入局部变量表1号位置
iload_1			从局部变量表1号位置加载数据到操作数栈
iinc 1 by 1		在局部变量表1号位置增加1
istore_1		将操作数栈中的值保存到局部变量表
return

------
最终i的值为0
```

#### 字节码文件的组成 –玩转字节码常用工具

-  javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件内 容。
- 直接输入javap查看所有参数。
- 输入`javap -v 字节码文件名称 `查看具体的字节码信息。（如果jar包需要先使用 `jar –xvf`命令解压）
- jclasslib也有Idea插件版本，建议开发时使用Idea插件版本，可以在代码编译之后实时看到字节码 文件内容。

##### 玩转字节码常用工具: 阿里arthas

- **Arthas** 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修 改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。
- 官网：https://arthas.aliyun.com/doc/
- dump 类的全限定名：dump已加载类的字节码文件到特定目录。
-  jad类的全限定名：反编译已加载类的源码。

## 类的生命周期

#### 加载

1. 加载(Loading)阶段第一步是类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。 程序员可以使用Java代码拓展的不同的渠道。
2. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中。
3. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。 生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息。
4. 、同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象。 作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后）。

- 对于开发者来说，只需要访问堆中的Class对象而不需要访问方法区中所有信息。 这样Java虚拟机就能很好地控制开发者访问数据的范围。
-  推荐使用 JDK自带的hsdb工具查看Java虚拟机内存信息。工具位于JDK安装目录下lib文件夹中的sa-jdi.jar中。
- 启动命令：java -cp sa-jdi.jar sun.jvm.hotspot.HSDB

#### 连接

##### 验证

-  连接（Linking）阶段的第一个环节是验证，验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规 范》中的约束。这个阶段一般不需要程序员参与。
- 主要包含如下四部分，具体详见《Java虚拟机规范》：
  - 文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求。
  - 元信息验证，例如类必须有父类（super不能为空）。
  - 验证程序执行指令的语义，比如方法内的指令执行到一半强行跳转到其他方法中去。
  - 符号引用验证，例如是否访问了其他类中private的方法等。

##### 准备

- 准备阶段为静态变量（static）分配内存并设置初始值。
- final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。

| 数据类型     | 初始值   |
| ------------ | -------- |
| int          | 0        |
| long         | 0L       |
| short        | 0        |
| char         | ‘\u0000’ |
| byte         | 0        |
| boolean      | false    |
| double       | 0.0      |
| 引用数据类型 | null     |

##### 解析

- 解析阶段主要是将常量池中的符号引用替换为直接引用。
- 符号引用就是在字节码文件中使用编号来访问常量池中的内容。
-  直接引用不在使用编号，而是使用内存中地址进行访问具体的数据。

#### 初始化

- 初始化阶段会执行静态代码块中的代码，并为静态变量赋值。
-  初始化阶段会执行字节码文件中clinit部分的字节码指令
-  以下几种方式会导致类的初始化：
  - 访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化。
  - 调用Class.forName(String className)。
  - new一个该类的对象时。
  - 执行Main方法的当前类。
- clinit指令在特定情况下不会出现，比如：如下几种情况是不会进行初始化指令执行的。
  - 无静态代码块且无静态变量赋值语句。
  - 有静态变量的声明，但是没有赋值语句。
  - 静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化。
- 直接访问父类的静态变量，不会触发子类的初始化。
- 子类的初始化clinit调用之前，会先调用父类的clinit初始化方法。
- 数组的创建不会导致数组中元素的类进行初始化。
- final修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化。

![image-20250730152547465](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250730152547465.png)

#### 使用

#### 卸载

## 类加载器

### 什么是类加载器

- 类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。 类加载器只参与加载过程中的字节码获取并加载到内存这一部分。

### 类加载器的分类

类加载器分为两类，一类是**Java代码**中实现的，一类是**Java虚拟机底层源码**实现的。

#### 启动类加载器（BootstrapClassLoader）

- 启动类加载器（BootstrapClassLoader）是由Hotspot虚拟 机提供的、使用C++编写的类加载器。
-  默认加载Java安装目录/jre/lib下的类文件，比如rt.jar， tools.jar，resources.jar等。

#### 扩展类加载器（Extension Class Loader）

- 扩展类加载器和应用程序类加载器都是JDK中提供的、使用Java编写的类加载器
- 它们的源码都位于sun.misc.Launcher中，是一个静态内部类。继承自URLClassLoader。具备通过目录 或者指定jar包将字节码文件加载到内存中。
-  默认加载Java安装目录/jre/lib/ext下的类文件。

#### 应用程序类加载器

- 加载我们自己实现的类和导入依赖的类

#### 自定义类加载器

重写findClass方法（保留了双亲委派机制）。 JDK9及之后扩展类加载器（Extension ClassLoader）变成了平台类加载器（Platform  ClassLoader）

### 双亲委派机制

#### 在Java中如何使用代码的方式去主动加载一个类呢？ 

方式1：使用Class.forName方法，使用当前类的类加载器去加载指定的类。 

方式2：获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载。

- 每个Java实现的类加载器中保存了一个成员变量叫“父”（Parent）类加载器，可以理解为它的上级， 并不是继承关系。
- 应用程序类加载器的parent父类加载器是扩展类加载器，而扩展类加载器的parent是空。
- 启动类加载器使用C++编写，没有上级类加载器。

1. **在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会 将加载请求委派给父类加载器。**
2. **如果类加载的parent为null，则会提交给启动类加载器处理。**
3.  **如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试 加载。**
4. **第二次再去加载相同的类，仍然会向上进行委派，如果某个类加载器加载过就会直接返回。**

**双亲委派机制指的是：自底向上查找是否加载过，再由顶向下进行加载。**

#### **双亲委派机制-解决三个问题**

1.重复的类：如果一个类重复出现在三个类加载 器的加载位置，应该由谁来加载？

启动类加载器加载，根据双亲委派 机制，它的优先级是最高的

2.String类能覆盖吗：在自己的项目中去创建一个 java.lang.String类，会被加载吗？

不能，会交由启动类加载器加载在 rt.jar包中的String类

3.类加载器的关系：这几个类加载器彼此之间存在关 系吗？

应用类加载器的父类加载器是扩展 类加载器，扩展类加载器没有父类 加载器，但是会委派给启动类加载 器加载

#### **双亲委派机制有什么用？**

- 保证类加载的安全性

通过双亲委派机制，让顶层的类加 载器去加载核心类，避免恶意代码 替换JDK中的核心类库，比如 java.lang.String，确保核心类 库的完整性和安全性。

- 避免重复加载

双亲委派机制可以避免同一个类被 多次加载，上层的类加载器如果加 载过类，就会直接返回该类，避免 重复加载。

### 打破双亲委派机制

- 一个Tomcat程序中是可以运行多个Web应用的，如果这两个应用中出现了相同限定名的类，比如Servlet类， Tomcat要保证这两个类都能加载并且它们应该是不同的类。
- 如果不打破双亲委派机制，当应用类加载器加载Web应用1中的MyServlet之后，Web应用2中相同限定名的 MyServlet类就无法被加载了。

#### 自定义类加载器

- Tomcat使用了自定义类加载器来实现应用之间类的隔离。 每一个应用会有一个独立的类加载器加载对应的类。

- 先来分析ClassLoader的原理，ClassLoader中包含了4个核心方法。

- 双亲委派机制的核心代码就位于loadClass方法中。

  ```java
  public Class<?> loadClass(String name)		
  类加载的入口，提供了双亲委派机制。内部会调用findClass 
  
  protected Class<?> findClass(String name)	
  由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。
  
  protected final Class<?> defineClass(String name, byte[] b, int off, int len)
  做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中
  
  protected final void resolveClass(Class<?> c)
  执行类生命周期中的连接阶段
  ```

- 打破双亲委派机制的核心就是重写loadclass方法

**两个自定义类加载器加载相同限定名的类，不会冲突吗？**

- 不会冲突，在同一个Java虚拟机中，只有相同类加载器+相同的类限定名才 会被认为是同一个类。
- 在Arthas中使用sc–d 类名的方式查看具体的情况

#### 线程上下文类加载器

**jdbc案例**：

-  JDBC中使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动。

-  DriverManager类位于rt.jar包中，由启动类加载器加载。

-  依赖中的mysql驱动对应的类，由应用程序类加载器来加载。

-  DriverManager属于rt.jar是启动类加载器加载的。而用户jar包中的驱动需要由应用类加载器加载，这就**违反 了双亲委派机制**。

  ![image-20250730155418500](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250730155418500.png)

DriverManage使用SPI机制，最终加载jar包中对应的驱动类。

**SPI中是如何获取到应用程序类加载器的？**

-  SPI中使用了线程上下文中保存的类加载器进行类的加载，这个类加载器一般是应用程序类加载器。

**总的来说：**

-  1、启动类加载器加载DriverManager。 

- 2、在初始化DriverManager时，通过SPI机制加载jar包中的myql驱动。 

- 3、SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象。 

- 这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，打破了双亲委派机制。

####  Osgi框架的类加载器

- 历史上，OSGi模块化框架。它存在同级之间的类加载器的委托加载。OSGi还使用类加载器实现了热部署的 功能。
-  热部署指的是在服务不停止的情况下，动态地更新字节码文件到内存中。

### JDK9之后的类加载器

JDK8及之前的版本中，扩展类加载器和应用程序类加载器的源码位于rt.jar包中的sun.misc.Launcher.java。

**JDK8之后的类加载器**

由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。

1. 启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。 Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。 启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。
2. 扩展类加载器被替换成了平台类加载器（Platform Class Loader）。 平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了 BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是 为了与老版本的设计方案兼容，自身没有特殊的逻辑。

## JVM 的内存区域

### 运行时数据区-总览

 Java虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区。

**线程不共享：**

- 程序计数器
- Java虚拟机栈
- 本地方法栈

**线程共享：**

- 方法区
- 堆

**内存调优学习路线：**

- 了解运行时内存结构

   了解JVM运行过程中每一部分的内存结构以 及哪些部分容易出现内存溢出

- 掌握内存问题的产生原因

  学习代码中常见的几种内存泄漏、 性能问题的常见原因

- 掌握内存调优的基本方法

  学习内存泄漏、性能问题等常见JVM问题 的常规解决方案

### 程序计数器

程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字 节码指令的地址。

- 在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的偏移量转换成内存地址。每一条字 节码指令都会拥有一个内存地址。
- 在代码执行过程中，程序计数器会记录下一行字节码指令的地址。执行完当前指令之后，虚拟机的执行引擎根据 程序计数器执行下一行指令。
- 程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。
- 在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并继 续解释运行。

**问题：程序计数器在运行中会出现内存溢出吗？**

- 内存溢出指的是程序在使用某一块内存区域时，存放的数据需要占用的内存 大小超过了虚拟机能提供的内存上限。
- 因为每个线程只存储一个固定长度的内存地址，**程序计数器是不会发生内存 溢出的。**
-  程序员无需对程序计数器做任何处理。

### java虚拟机栈

- Java虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，先 进后出（First In Last Out）,每一个方法的调用使用一个栈帧（Stack Frame）来保存。

-  Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线 程中执行，每个线程都会包含一个自己的虚拟机栈。

#### 栈帧的组成

##### 局部变量表

- 局部变量表的作用是在方法执行过程中存放所有的局部变量。编译成字节码文件时就可以确定局部变 量表的内容。
-  栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其 他类型占用一个槽。
- **实例方法中的序号为0的位置存放的是this**，指的是当前调用方法的对象，运行时会在内存中存放实例对象 的地址。
- 方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致。
- 局部变量表保存的内容有：实例方法的this对象，方法的参数，方法体中声明的局部变量。
- 为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。

##### 操作数栈

- 操作数栈是栈帧中虚拟机在执行指令过程中用来存放中间数据的一块区域。他是一种栈式的数据结构，如 果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。
- 在编译期就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小。

**示例：**

```java
int i = 0;
int j = i + 1;

-----字节码指令
iconst_0		将常量0放入操作数栈
istore_1		从操作数栈取出放入局部变量表1号位置
iload_1			将局部变量表1中的数据放入操作数栈
iconst_1		将常量1放入操作数栈
iadd			将操作数栈顶部的两个数据进行累加
istore_2		结果放入局部变量表2号位置
return			方法结束，返回
```



##### 帧数据

- 当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池 中的内存地址。**动态链接**就保存了编号到运行时常量池的内存地址的映射关系。
-  **方法出口**指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的 下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。
- **异常表**存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。

#### 栈内存溢出

- Java虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出。
- Java虚拟机栈内存溢出时会出现StackOverflowError的错误

> 如果我们不指定栈的大小，JVM 将创建一个 具有默认大小的栈。大小取决于操作系统和 计算机的体系结构。
>
> 1.Linux 
>
> ​			x86（64 位）：1 MB 
>
> ​			ppc：2 MB
>
> 2.BSD
>
> ​			x86（64 位）：1 MB 
>
> 3.Solaris
>
> ​			 64 位 ：1 MB
>
> 4.Windows
>
> 基于操作系统默认值

### 本地方法栈

-  Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是**native本地方法的栈帧**。
- 在Hotspot虚拟机中，**Java虚拟机栈和本地方法栈实现上使用了同一个栈空间**。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。

### 堆

- 一般Java程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上。
- 栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，**通过静态变量就可以实 现对象在线程之间共享。**

堆空间有三个需要关注的值，used total max。

- used指的是当前已使用的堆内存，total是java虚拟机已经分配的可用堆内存，max是java虚拟机可以分配的最大堆内存。
- arthas中堆内存used total max三个值可以通过dashboard命令看到。
-  **随着堆中的对象增多，当total可以使用的内存即将不足时，java虚拟机会继续分配内存给堆。**
- 如果堆内存不足，java虚拟机就会不断的分配内存，total值会变大。**total最多只能与max相等**

### 方法区

方法区是《Java虚拟机规范》中设计的虚拟概念，每款Java虚拟机在实现上都各不相同。Hotspot设计如下：

- JDK7及之前的版本将方法区存放在**堆区域**中的**永久代空间**，堆的大小由虚拟机参数来控制
- JDK8及之后的版本将方法区存放在**元空间**中，元空间位于操作系统维护的**直接内存**中，默认情况下只要不 超过操作系统承受的上限，可以一直分配。

 方法区是存放基础信息的位置，线程共享，主要包含三部分内容：

- 类的元信息：保存了所有类的基本信息
- 运行时常量池：保存了字节码文件中的常量池内容
- 字符串常量池：保存了字符串常量

#### 类的元信息

方法区是用来存储每个类的基本信息（元信息），一般称之为**InstanceKlass对象**。在类的加载阶段完成

#### 运行时常量池

-  方法区除了存储类的元信息之外，还存放了运行时常量池。常量池中存放的是字节码中的常量池内容。
- 字节码文件中通过编号查表的方式找到常量，这种常量池称**为静态常量池**。当常量池加载到内存中之后，可以通 过内存地址快速的定位到常量池中的内容，这种常量池称为**运行时常量池**。

#### 字符串常量池

- 方法区中除了类的元信息、运行时常量池之外，还有一块区域叫字符串常量池(StringTable)。
- 字符串常量池存储在代码中定义的**常量字符串**内容。比如“123” 这个123就会被放入字符串常量池。

#### 字符串常量池和运行时常量池有什么关系？

早期设计时，字符串常量池是属于运行时常量池的一部分，他们存储的位置也是一致的。后续做出了调整， 将字符串常量池和运行时常量池做了拆分。

- JDK7之前

  运行时常量池逻辑包含字符串常量池， hotspot虚拟机对方法区的实现为永久代

- JDK7

  字符串常量池被从方法区拿到了堆中, 运行时常量池剩下的东西还在永久代

- JDK8之后

   hotspot移除了永久代用元空间 (Metaspace)取而代之, 字符串常量池 还在堆

#### Intern方法：

- String.intern()方法是可以手动将字符串放入字符串常量池中，分别在JDK6 JDK8下执行 代码，JDK6 中结果是false false ，JDK8中是true false

### 直接内存

直接内存（Direct Memory）并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。 在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题:

1. Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。
2. **IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。 现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。**

-  要创建直接内存上的数据，可以使用ByteBuffer。
-  语法： ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);
- 注意事项： arthas的memory命令可以查看直接内存大小，属性名direct。

## JVM 的垃圾回收

- 线程不共享的部分，都是伴随着**线程的创建而创建，线程的销毁而销毁**。而方法的栈帧在执行完方法之后就会 自动弹出栈并释放掉对应的内存。

### 方法区的回收

- 方法区中能回收的内容主要就是**不再使用的类**。

判定一个类可以被卸载。需要同时满足下面三个条件：

1、**此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。** 

2、**加载该类的类加载器已经被回收。** 

3、**该类对应的 java.lang.Class 对象没有在任何地方被引用。**

**手动触发回收**：

- 如果需要手动触发垃圾回收，可以调用System.gc()方法。

- 语法：System.gc()

-  注意事项：

  调用System.gc()方法并不一定会立即回收垃圾，仅仅是向Java虚拟机发送一个垃圾回收的请求，具体是否需要 执行垃圾回收Java虚拟机会自行判断。

> 开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中。 每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类 加载器。重新创建类加载器，重新加载jsp文件。

### 堆回收

#### 引用计数法和可达性分析法

Java中的对象是否能被回收，是根据对象是否被引用来决定的。如果对象被引用了，说明该对象还 在使用，不允许被回收。

- 引用计数法会为每个对象维护一个引用计数器，**当对象被引用时加1，取消引用时减1**。

- Java使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的根对象（GC  Root）和普通对象，对象与对象之间存在引用关系。

  下图中A到B再到C和D，形成了一个引用链，可达性分析算法指的是如果从某个到GC Root对象是可达的，对象就 不可被回收。

  ![image-20250731092508250](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731092508250.png)

##### 引用计数法的缺点-循环引用

引用计数法的优点是实现简单，C++中的智能指针就采用了引用计数法，但是它也存在缺点，主要有两点： 

1.每次引用和取消引用都需要**维护计数器**，对系统性能会有一定的影响 

2.存在**循环引用**问题，所谓循环引用就是**当A引用B，B同时引用A**时会出现**对象无法回收**的问题。

##### 哪些对象被称之为GC Root对象呢？

- 线程Thread对象.
- 系统类加载器加载的java.lang.Class对象。
- 监视器对象，用来保存同步锁synchronized关键字持有的对象。
- 本地方法调用时使用的全局对象。

##### 三色标记法



#### 五种对象引用

- 强引用
- 软引用
- 弱引用
- 虚引用
- 终结器引用

##### 强引用

可达性算法中描述的对象引用，一般指的是强引用，即是GCRoot对象对普通对象有引用关系，只要这层关系存在， 普通对象就不会被回收。

##### 软引用

- 软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，当**程序内存不足**时，就会将软 引用中的数据进行回收。

- 在JDK 1.2版之后提供了`SoftReference`类来实现软引用，软引用常用于缓存中。

**软引用的执行过程**如下：

1.将对象使用软引用包装起来，`new SoftReference<对象类型>(对象)。` 

2.内存不足时，虚拟机尝试进行垃圾回收。 

3.如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象。 

4.如果依然内存不足，抛出OutOfMemory异常

```java
byte[] bytes = new byte[1024*1024*100];
SoftReference<byte[]> softReference = new SoftReference<byte[]>(bytes);

----
将100m的数据放入软引用中
```

软引用中的对象如果在内存不足时回收，**SoftReference对象本身**也需要被回收。如何知道哪些SoftReference对 象需要回收呢？

SoftReference提供了一套**队列机制**： 

1、软引用**创建**时，通过**构造器传入引用队列** 

2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列 

3、通过代码遍历引用队列，将SoftReference的强引用删除

软引用也可以使用**继承自SoftReference类**的方式来实现，StudentRef类就是一个**软引用对象**。 通过构造器传入软引用包含的对象，以及引用队列。

```java
class StudentRef extends SoftReference<Student>
通过继承实现软引用

public StudentRef(Student em, ReferenceQueue<Student> q){
	super(em,q);
}
构造器传入对象
```



##### 弱引用

- 弱引用的**整体机制和软引用基本一致**，区别在于弱引用包含的对象在垃圾回收时，**不管内存够不够都会直接被回收**。
- 在JDK 1.2版之后提供了`WeakReference`类来实现弱引用，弱引用主要在**ThreadLocal**中使用。
- 弱引用**对象本身**也可以使用**引用队列**进行回收。

##### 虚引用和终结器引用

- 这两种引用在常规开发中是不会使用的。
- **虚引用**也叫幽灵引用/幻影引用，**不能通过虚引用对象获取到包含的对象**。虚引用唯一的用途是当**对象被垃圾回 收器回收时可以接收到对应的通知**。Java中使用`PhantomReference`实现了虚引用，直接内存中为了及时知道 直接内存对象不再使用，从而回收内存，使用了虚引用来实现。
-  **终结器引用**指的是在对象需要被回收时，终结器引用会**关联对象并放置在Finalizer类中的引用队列中**，在稍后 由一条由**FinalizerThread线程**从队列中获取对象，然后**执行对象的finalize方法**，在对象**第二次被回收时**，该 对象才真正的被回收。在这个过程中可以在**finalize方法**中再将自身对象使用强引用关联上(避免被回收)，但是不建议这样做。

#### 垃圾回收算法

Java是如何实现垃圾回收的呢？简单来说，垃圾回收要做的有两件事：

1. 找到内存中存活的对象
2. 释放不再存活对象的内存，使得程序能再次利用这部分空间

Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要**停止所 有的用户线程**。这个过程被称之为**Stop The World简称STW**，如果STW时间过长则会影响用户的使用。

- 1960年John McCarthy发布了第一个GC算法：**标记-清除算法**
-  1963年Marvin L. Minsky 发布了**复制算法**。

本质上后续所有的垃圾回收算法，都是在上述两种算法的基础上优化而来。

##### 垃圾回收算法的评价标准

1. 吞吐量

   吞吐量指的是 CPU 用于**执行用户代码的时间与 CPU 总执行时间的比值**，即**吞吐量 = 执行用户代码时间 / （执行用户代码时间 + GC时间）**。吞吐量数值越高，垃圾回收的效率就越高。

2. 最大暂停时间

   最大暂停时间指的是所有在垃圾回收过程中的**STW时间最大值**。最大暂停时间越短，用户使用系统时 受到的影响就越短。

3. 堆使用效率

   不同垃圾回收算法，对堆内存的使用方式是不同的。比如**标记清除算法，可以使用完整的堆内存**。而**复制算 法会将堆内存一分为二，每次只能使用一半内存**。从堆使用效率上来说，标记清除算法要优于复制算法。

上述三种评价标准：堆使用效率、吞吐量，以及最大暂停时间不可兼得。 

一般来说，**堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量。** 

不同的垃圾回收算法，适用于不同的场景。

##### 标记清除算法

标记清除算法的核心思想分为两个阶段：

1.**标记阶段**，将所有存活的对象进行标记。Java中使用**可达性分析算法**，从GC Root开始通过引用链遍历出 所有存活对象。 

2**.清除阶段**，从内存中**删除没有被标记也就是非存活对象**。

**优点**：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。

**缺点：**1. **碎片化问题**

​				由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一 个比较大的空间，				很有可能这些内存单元的大小过小无法进行分配。

​			2.**分配速度慢**。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才 能获得合适的内存空				间。

##### 复制算法

复制算法的**核心思想**是： 

1.准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。 

2.在垃圾回收GC阶段，将From中存活对象复制到To空间。 

3.将两块空间的From和To名字互换。

**完整的复制算法的例子：**

1.将堆内存分割成两块From空间To空间，对象分配阶段，创建对象。 

2.GC阶段开始，将GC Root搬运到To空间 

3.将GC Root关联的对象，搬运到To空间 

4.清理From空间，并把名称互换

**优点**

- **吞吐量高**

  复制算法只需要**遍历一次**存活对象 复制到To空间即可，比标记-整理 算法少了一次遍历的过程，因而性 能较好，但是不如标记-清除算法， 因为标记清除算法不需要进行对象 的移动

- **不会发生碎片化**

  复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间

**缺点：**

- **内存使用效率低**

  每次只能让一半的内存空间来为创 建对象使用

##### 标记-整理算法

标记整理算法也叫**标记压缩**算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。

核心思想分为两个阶段：

1.**标记阶段**，将所有存活的对象进行标记。Java中使用**可达性分析算法**，从GC Root开始通过引用链遍历出 所有存活对象。 

2.**整理阶段**，将存活对象移动到堆的一端。清理掉存活对象的内存空间。

**优点**

- **内存使用效率高**

  整个堆内存都可以使用，不会像复 制算法只能使用半个堆内存

- **不会发生碎片化**

  在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有 效空间

**缺点：**

- **整理阶段的效率不高**

  整理算法有很多种，比如**Lisp2整 理算法**需要对整个堆中的对象搜索3 次，整体性能不佳。可以通过**Two Finger**、**表格算法**、**ImmixGC**等高 效的整理算法优化此阶段的性能

##### 分代GC

现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法**组合进行使用**，其中应用最广的就是分代垃圾回收 算法(Generational GC)。

分代垃圾回收将整个内存区域划分为年轻代和老年代：

![image-20250731100322616](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731100322616.png)

- 分代回收时，创建出来的对象，首先会被放入**Eden**伊甸园区。 随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为 **Minor GC或者Young GC**。 Minor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。
- 接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。 此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入S0。 **注意**：每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1
- 如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被**晋升至老年代**。 当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发**Full GC**，Full GC会对**整个堆**进行垃圾回收。 如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常

#### 垃圾回收器

-  系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回 给用户之后就可以释放了。
- 老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。
- 在虚拟机的默认设置中，**新生代大小要远小于老年代的大小。**

为什么分代GC算法要把堆分成年轻代和老年代？

1、可以通过**调整年轻代和老年代的比例**来适应不同类型的应用程序，提高内存的利用率和性能。 

2、**新生代和老年代使用不同的垃圾回收算法**，新生代一般选择复制算法，老年代可以选择标记-清除和标记-整理 算法，由程序员来选择灵活度较高。 

3、分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full  gc),STW时间就会减少。

垃圾回收器是垃圾回收算法的具体实现。 

由于垃圾回收器分为年轻代和老年代，**除了G1之外其他垃圾回收器必须成对组合进行使用**。 具体的关系图如下：

![image-20250731100927611](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731100927611.png)

##### 年轻代-Serial垃圾回收器

Serial是一种**单线程串行回收**年轻代的垃圾回收器。![image-20250731101109971](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731101109971.png)

| 回收年代和算法            | 优点                        | 缺点                                                         | 适用场景                                    |
| ------------------------- | --------------------------- | ------------------------------------------------------------ | ------------------------------------------- |
| -  年轻代<br> -  复制算法 | 单CPU处理器下吞吐量非常出色 | 多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待 | Java编写的客户端程序或者硬件 配置有限的场景 |

##### 老年代-SerialOld垃圾回收器

SerialOld是Serial垃圾回收器的老年代版本，采用**单线程串行回收**

| 回收年代和算法                 | 优点                        | 缺点                                                         | 适用场景                                             |
| ------------------------------ | --------------------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| -  老年代<br> -  标记整理-算法 | 单CPU处理器下吞吐量非常出色 | 多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待 | 与Serial垃圾回收器搭配使用， 或者在CMS特殊情况下使用 |

##### 年轻代-ParNew垃圾回收器

ParNew垃圾回收器本质上是对Serial在多 CPU下的优化，使用**多线程**进行垃圾回收

![image-20250731101819255](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731101819255.png)

| 回收年代和算法             | 优点                       | 缺点                                              | 适用场景                                               |
| -------------------------- | -------------------------- | ------------------------------------------------- | ------------------------------------------------------ |
| -   年轻代<br> -  复制算法 | 多CPU处理器下停顿时间 较短 | 吞吐量和停顿时间不如G1， 所以在JDK9之后不建议使用 | JDK8及之前的版本中，与**CMS** 老年代垃圾回收器搭配使用 |

##### 老年代-CMS(Concurrent Mark Sweep)垃圾回收器

CMS垃圾回收器关注的是**系统的暂停时间**， 允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间。

![image-20250731101954609](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731101954609.png)

| 回收年代和算法                 | 优点                                            | 缺点                                        | 适用场景                                                     |
| ------------------------------ | ----------------------------------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| -   老年代<br> -  标记清除算法 | 系统由于垃圾回收出现的停 顿时间较短，用户体验好 | 1、内存碎片问题 2、退化问题 3、浮动垃圾问题 | 大型的互联网系统中用户请求数据量大、频率高的场景比如订单接口、商品接口等 |

CMS执行步骤：

1.**初始标记**，用极短的时间标记出GCRoots能直接关联到的对象。 

2.**并发标记,**   标记所有的对象，用户线程不需要暂停。 

3.**重新标记**，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。 

4.**并发清理**，清理死亡的对象，用户线程不需要暂停。

**缺点：**

1、CMS使用了**标记-清除**算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。 这样会导致用户线程暂停，可以使用-XX:CMSFullGCsBeforeCompaction=N 参数（默认0）调整N次Full GC之 后再整理。 

2.、无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。 

3、如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。

**CMS垃圾回收器存在的问题 –线程资源争抢问题**

- 在CMS中并发阶段运行时的线程数可以通过-XX:ConcGCThreads参数设置，默认值为0，由系统计算得出。

- 计算公式为(-XX:ParallelGCThreads定义的线程数 + 3) / 4， ParallelGCThreads是STW停顿之后的 并行线程数

- ParallelGCThreads是由处理器核数决定的：

  1、当cpu核数小于8时，ParallelGCThreads = CPU核数 

  2、否则 ParallelGCThreads = 8 + (CPU核数– 8 )*5/8

- 由于CPU的核心数有限，就会影响用户线程执行的性能。

##### 年轻代-Parallel Scavenge垃圾回收器

Parallel Scavenge是JDK8默认的年轻代垃圾回收器， **多线程并行回收**，关注的是**系统的吞吐量**。具备**自动调整堆内存大小**的特点。

![image-20250731101819255](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731101819255.png)

| 回收年代和算法             | 优点                                                         | 缺点                   | 适用场景                                                     |
| -------------------------- | ------------------------------------------------------------ | ---------------------- | ------------------------------------------------------------ |
| -   年轻代<br> -  复制算法 | 吞吐量高，而且手动可控。 为了提高吞吐量，虚拟机会 动态调整堆的参数 | 不能保证单次的停顿时间 | 后台任务，不需要与用户交互，并 且容易产生大量的对象 比如：大数据的处理，大文件导出 |

##### 老年代-Parallel Old垃圾回收器

Parallel Old是为Parallel Scavenge收集器 设计的老年代版本，利用**多线程并发收集**。

![image-20250731101819255](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731101819255.png)

| 回收年代和算法                   | 优点                           | 缺点             | 适用场景                     |
| -------------------------------- | ------------------------------ | ---------------- | ---------------------------- |
| -   老年代<br> -   标记-整理算法 | 并发收集，在多核CPU下 效率较高 | 暂停时间会比较长 | 与Parallel Scavenge配套使 用 |

- Parallel Scavenge允许手动设置最**大暂停时间和吞吐量**。
- Oracle官方建议在使用这个组合时，**不要设置堆内存 的最大值**，垃圾回收器会根据最大暂停时间和吞吐量 自动调整内存大小。

##### G1垃圾回收器

JDK9之后默认的垃圾回收器是G1（Garbage First）垃圾回收器。 

**Parallel Scavenge关注吞吐量**，允许用户设置最大暂停时间 ，但是会减少年轻代可用空间的大小。 

**CMS关注暂停时间**，但是吞吐量方面会下降。 

而G1设计目标就是将上述两种垃圾回收器的优点融合：

1.**支持巨大的堆空间回收，并有较高的吞吐量。** 

2.**支持多CPU并行垃圾回收。** 

3.**允许用户设置最大暂停时间。**

JDK9之后强烈建议使用G1垃圾回收器。

###### G1垃圾回收器 –内存结构

G1出现之前的垃圾回收器，内存结构一般是连续的，如下图：

![image-20250731103050576](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731103050576.png)

G1的整个堆会被划分成**多个大小相等的区域**，称之为区Region，区域不要求是连续的。分为Eden、Survivor、 Old区。

Region的大小通过堆空间大小/2048计算得到，也可以通过参数-XX:G1HeapRegionSize=32m指定(其 中32m指定region大小为32M)，Region size必须是2的指数幂，取值范围从1M到32M。

![image-20250731103135952](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731103135952.png)

G1垃圾回收有两种方式：

- 年轻代回收（Young GC）
- 混合回收（Mixed GC）

###### G1垃圾回收器 –年轻代回收

- 年轻代回收（Young GC），**回收Eden区和Survivor区中不用的对象**。会导致STW，G1中可以通过参数-XX:MaxGCPauseMillis=n（默认200） 设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地 保证暂停时间。

**执行流程：**

1、新创建的对象会存放在Eden区。当G1判断年轻代区不足（max默认60%），无法分配对象时需要回收时会执行 Young GC。 

2、标记出Eden和Survivor区域中的存活对象， 

3、根据配置的最大暂停时间选择某些区域将存活对象**复制**到一个新的Survivor区中（年龄+1），清空这些区域。

​	 **注意：**G1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的**平均耗时**，以作为下次回收时的 参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了。 比如 -XX:MaxGCPauseMillis=n（默认200），**每个Region回收耗时40ms，那么这次回收最多只能回收4个Region。**

4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。 

5、当某个存活对象的年龄到达阈值（默认15），将被放入老年代。

6、部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。比如堆内存是 4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果对象过大会横跨多个Region。

7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时 （-XX:InitiatingHeapOccupancyPercent默认45%）**会触发混合回收MixedGC。回收所有年轻代和 部分老年代的对象以及大对象区**。采用**复制算法**来完成。

###### G1垃圾回收器 –混合回收

- 混合回收分为：**初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark或者Finalize  Marking）、并发清理（cleanup）**
-  G1对老年代的清理会**选择存活度最低的区域**来进行回收，这样可以保证回收效率最高，这也是G1（Garbage  first）名称的由来。
- 最后清理阶段使用复制算法，不会产生内存碎片。

![image-20250731103747264](C:\Users\34978\AppData\Roaming\Typora\typora-user-images\image-20250731103747264.png)

**注意：**如果清理过程中发现**没有足够的空Region存放转移的对象**，会出现**Full GC**。**单线程执行标记-整理算法**， 此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。

| 回收年代和算法                     | 优点                                                         | 缺点               | 适用场景                            |
| ---------------------------------- | ------------------------------------------------------------ | ------------------ | ----------------------------------- |
| -   年轻代+老年代<br> -   复制算法 | 对比较大的堆如超过6G的堆回收时，延迟可控<br> 不会产生内存碎片<br> 并发标记的SATB算法效率高 | JDK8之前还不够成熟 | JDK8最新版本、JDK9之后建 议默认使用 |

##### 总结

垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选 择如下：

JDK8及之前：

**ParNew + CMS（关注暂停时间）、Parallel Scavenge + Parallel Old (关注 吞吐量)、G1（JDK8之前不建议，较大堆并且关注暂停时间）**

JDK9之后:

**G1（默认）**

从JDK9之后，由于G1日趋成熟，JDK默认的垃圾回收器已经修改为G1，所以 强烈建议在生产环境上使用G1。